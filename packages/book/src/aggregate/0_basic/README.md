## TODO:

- 0_basicの制約を実装する
- 1_other...は実装し直し。具体的には商品を外すだけ

## 注文の集約を考える

- ECサイトでログインユーザー毎に独立した購買ができる
- 注文をするユースケースを想定する
- OrderItemを複数束ねて一貫性のある注文したい (集約)
- Orderエンティティを作成する

## 制約を設ける

- [x] 合計注文数上限がある。
- [x] 品目は10種類までである。(OrderItem)
- [x] 注文には商品を1つのみ指定可能。(実装でカバー)
- [x] (購入注文承認限度額) <- これは商品から価格を取ってくる必要がある..

## 商品の価格が変更した時に、整合性についてどのように考えるか？

https://stackoverflow.com/questions/65262165/product-price-changed-while-creating-order

1. ユーザーはオーダー作成画面に入り、OrderItems で新しいオーダーの作成を開始する。
2. ユーザーは商品カタログから商品Xを選択し、数量を追加する。
3. 商品XのOrderItemがOrderに作成され、ユーザーは別の商品を追加する。
4. オーダーが保存される前に、管理者は商品Xの価格を変更する。

商品もロックをかけるか？
ECサイトに多くのカスタマーがいて、1つの商品の購買を同時にする(高競合)ため、ユーザーは商品価格が変更になるまで購買を待ち続けることになる。利用体験が悪くなる。
一方、商品の価格変更の変更は少ない。

競合をなくすためにはどのようは方法があるか？

**注文時刻と価格変更時刻を記録し、それらを比較する**

しかし時刻というのは脆弱である。特に分散システムだと揺れが生じる。
マイクロ秒のタイミングの違いは、中核となるビジネス行動には影響を与えてはならない。
そのようなことがあり得るとしたら要件のバグということになる。

**注文行動をしている時に表示されている価格を適用する**

この場合はカートにいれた注文品目の価格のまま適用され、サプライヤーが意図した金額でない注文が行われる可能性がある。

**価格適用期間を設ける**

- 価格変更が適用されるのは1時間後からである。
- 注文する前は注文確認画面を設け、価格が変更するタイミングを明示する
- 最終的に確定した注文時刻によって決定するが、それはユーザーが合意したものとみなす


## 方法

- Productを直接依存させずに、ProductIdだけを参照する
- OrderItemをエンティティとみなす
- Orderをルートエンティティとみなす

## 商品を別集約にする理由

- 商品名や価格などは別のライフサイクルで変更されるため
- (そもそも商品マスタ管理が外部システムで管理されている場合は、ライフサイクルを分けざるをえない)
  - 分散トランザクションはNG
- 注文する時の整合性をProductに含める必要はない
  - 注文する時のトランザクションProductの名前や価格を変更しないので参照する必要がない



## イベントとリソース

- OrderCreated、OrderCanceledをイベント
- Orderをリソースとする
- 注文明細をRead Modelとする
